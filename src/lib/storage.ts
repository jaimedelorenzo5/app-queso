import { supabase } from './supabase';

// Storage bucket names
const BUCKETS = {
  CHEESE_PHOTOS: 'cheese-photos',
  USER_UPLOADS: 'user-uploads',
} as const;

// Storage helpers
export const storage = {
  // Upload user photo to user-uploads bucket
  uploadUserPhoto: async (file: File | Blob, fileName: string) => {
    const fileExt = fileName.split('.').pop();
    const filePath = `${Date.now()}.${fileExt}`;
    
    const { data, error } = await supabase.storage
      .from(BUCKETS.USER_UPLOADS)
      .upload(filePath, file, {
        cacheControl: '3600',
        upsert: false,
      });

    if (error) return { error };

    // Get signed URL for immediate access
    const { data: signedUrlData } = await supabase.storage
      .from(BUCKETS.USER_UPLOADS)
      .createSignedUrl(filePath, 3600); // 1 hour

    return {
      path: filePath,
      urlSigned: signedUrlData?.signedUrl,
      error: null,
    };
  },

  // Promote photo from user-uploads to cheese-photos (after moderation)
  promoteToPublic: async (photoPath: string, cheeseId: string) => {
    // Download from user-uploads
    const { data: downloadData, error: downloadError } = await supabase.storage
      .from(BUCKETS.USER_UPLOADS)
      .download(photoPath);

    if (downloadError) return { error: downloadError };

    // Upload to cheese-photos with new path
    const newPath = `${cheeseId}/${photoPath}`;
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from(BUCKETS.CHEESE_PHOTOS)
      .upload(newPath, downloadData, {
        cacheControl: '31536000', // 1 year
        upsert: false,
      });

    if (uploadError) return { error: uploadError };

    // Delete from user-uploads
    await supabase.storage
      .from(BUCKETS.USER_UPLOADS)
      .remove([photoPath]);

    // Get public URL
    const { data: publicUrlData } = supabase.storage
      .from(BUCKETS.CHEESE_PHOTOS)
      .getPublicUrl(newPath);

    return {
      path: newPath,
      urlPublic: publicUrlData.publicUrl,
      error: null,
    };
  },

  // Get public URL for cheese photos
  getPublicURL: (path: string) => {
    const { data } = supabase.storage
      .from(BUCKETS.CHEESE_PHOTOS)
      .getPublicUrl(path);
    return data.publicUrl;
  },

  // Get signed URL for private photos
  getSignedURL: async (path: string, ttl = 3600) => {
    const { data, error } = await supabase.storage
      .from(BUCKETS.USER_UPLOADS)
      .createSignedUrl(path, ttl);
    return { url: data?.signedUrl, error };
  },

  // Delete file from storage
  deleteFile: async (bucket: string, path: string) => {
    const { error } = await supabase.storage
      .from(bucket)
      .remove([path]);
    return { error };
  },

  // Get thumbnail URL (appends -sm.webp or -lg.webp)
  getThumbnailURL: (originalPath: string, size: 'sm' | 'lg' = 'sm') => {
    const pathWithoutExt = originalPath.replace(/\.[^/.]+$/, '');
    const thumbnailPath = `${pathWithoutExt}-${size}.webp`;
    
    const { data } = supabase.storage
      .from(BUCKETS.CHEESE_PHOTOS)
      .getPublicUrl(thumbnailPath);
    return data.publicUrl;
  },

  // Upload with automatic thumbnail generation
  uploadWithThumbnails: async (
    file: File | Blob,
    fileName: string,
    cheeseId: string
  ) => {
    // Upload original
    const originalPath = `${cheeseId}/${Date.now()}_original.${fileName.split('.').pop()}`;
    const { data: originalData, error: originalError } = await supabase.storage
      .from(BUCKETS.CHEESE_PHOTOS)
      .upload(originalPath, file, {
        cacheControl: '31536000',
        upsert: false,
      });

    if (originalError) return { error: originalError };

    // Get public URL for original
    const { data: publicUrlData } = supabase.storage
      .from(BUCKETS.CHEESE_PHOTOS)
      .getPublicUrl(originalPath);

    return {
      originalPath,
      originalUrl: publicUrlData.publicUrl,
      // Thumbnails will be generated by edge function
      thumbnailSmUrl: storage.getThumbnailURL(originalPath, 'sm'),
      thumbnailLgUrl: storage.getThumbnailURL(originalPath, 'lg'),
      error: null,
    };
  },
};

// Image processing utilities
export const imageUtils = {
  // Get image dimensions from file
  getImageDimensions: (file: File): Promise<{ width: number; height: number }> => {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve({ width: img.width, height: img.height });
      };
      img.src = URL.createObjectURL(file);
    });
  },

  // Compress image before upload
  compressImage: async (
    file: File,
    maxWidth = 1200,
    maxHeight = 1200,
    quality = 0.8
  ): Promise<Blob> => {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d')!;
      const img = new Image();

      img.onload = () => {
        // Calculate new dimensions
        let { width, height } = img;
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        if (height > maxHeight) {
          width = (width * maxHeight) / height;
          height = maxHeight;
        }

        canvas.width = width;
        canvas.height = height;

        // Draw and compress
        ctx.drawImage(img, 0, 0, width, height);
        canvas.toBlob(resolve, 'image/jpeg', quality);
      };

      img.src = URL.createObjectURL(file);
    });
  },

  // Generate filename with timestamp
  generateFileName: (originalName: string, prefix = '') => {
    const timestamp = Date.now();
    const extension = originalName.split('.').pop();
    return `${prefix}${timestamp}.${extension}`;
  },
};

// File validation
export const fileValidation = {
  // Check if file is an image
  isImage: (file: File): boolean => {
    return file.type.startsWith('image/');
  },

  // Check file size (default 5MB)
  isValidSize: (file: File, maxSizeMB = 5): boolean => {
    return file.size <= maxSizeMB * 1024 * 1024;
  },

  // Get allowed image types
  getAllowedTypes: (): string[] => {
    return ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
  },

  // Validate file for upload
  validateFile: (file: File, maxSizeMB = 5): { isValid: boolean; error?: string } => {
    if (!fileValidation.isImage(file)) {
      return { isValid: false, error: 'El archivo debe ser una imagen' };
    }

    if (!fileValidation.isValidSize(file, maxSizeMB)) {
      return { isValid: false, error: `El archivo debe ser menor a ${maxSizeMB}MB` };
    }

    const allowedTypes = fileValidation.getAllowedTypes();
    if (!allowedTypes.includes(file.type)) {
      return { isValid: false, error: 'Formato de imagen no soportado' };
    }

    return { isValid: true };
  },
};
